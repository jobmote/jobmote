-- jobmote.de â€“ Supabase Setup (SQL Editor)
--
-- Goals
-- 1) Auth via Supabase Auth (email + password) with email confirmation enabled.
-- 2) No self-service creation of admin/Company accounts.
--    - New signups become role = 'user'.
--    - Admin/Company roles are assigned by an admin via profiles table.
-- 3) Admin can moderate all jobs, assign roles, and ban users temporarily or permanently.
-- 4) Company can create/update/delete own jobs.

-- ------------------------------
-- Helpers
-- ------------------------------
create or replace function public.is_admin()
returns boolean
language sql
stable
as $$
  select exists (
    select 1 from public.profiles p
    where p.id = auth.uid()
      and lower(p.role) = 'admin'
      and coalesce(p.banned_permanent,false) = false
      and (p.banned_until is null or p.banned_until <= now())
  );
$$;

create or replace function public.is_company()
returns boolean
language sql
stable
as $$
  select exists (
    select 1 from public.profiles p
    where p.id = auth.uid()
      and lower(p.role) in ('company','admin')
      and coalesce(p.banned_permanent,false) = false
      and (p.banned_until is null or p.banned_until <= now())
  );
$$;

-- ------------------------------
-- Profiles
-- ------------------------------
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  email text unique,
  role text not null default 'user',
  banned_until timestamptz null,
  banned_permanent boolean not null default false,
  created_at timestamptz not null default now()
);

alter table public.profiles enable row level security;

-- User can read own profile
drop policy if exists "read own profile" on public.profiles;
create policy "read own profile"
on public.profiles
for select
using (auth.uid() = id);

-- Admin can read all profiles
drop policy if exists "admin read profiles" on public.profiles;
create policy "admin read profiles"
on public.profiles
for select
using (public.is_admin());

-- Create profile automatically via trigger; still allow insert for edge cases
drop policy if exists "insert own profile" on public.profiles;
create policy "insert own profile"
on public.profiles
for insert
with check (auth.uid() = id);

-- User can update own profile (future-proof; role/ban should be handled by admin policy below)
drop policy if exists "update own profile" on public.profiles;
create policy "update own profile"
on public.profiles
for update
using (auth.uid() = id)
with check (auth.uid() = id);

-- Admin can update any profile (assign role, ban/unban)
drop policy if exists "admin update profiles" on public.profiles;
create policy "admin update profiles"
on public.profiles
for update
using (public.is_admin())
with check (public.is_admin());

-- ------------------------------
-- Jobs
-- ------------------------------
create table if not exists public.jobs (
  id bigint generated by default as identity primary key,
  owner_id uuid not null references public.profiles(id) on delete cascade,
  company text not null,
  title text not null,
  description text not null,
  pay numeric,
  hours_per_week integer,
  category text,
  language text,
  region text,
  link text,
  image_url text,
  requirements text[] not null default '{}',
  featured boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.jobs enable row level security;

-- Public can read jobs (anonymous users included)
drop policy if exists "public read jobs" on public.jobs;
create policy "public read jobs"
on public.jobs
for select
using (true);

-- Companys/Admins can insert jobs
drop policy if exists "company insert jobs" on public.jobs;
create policy "company insert jobs"
on public.jobs
for insert
with check (
  public.is_company() and owner_id = auth.uid()
);

-- Companys can update/delete own jobs; admins all jobs
drop policy if exists "company update own jobs" on public.jobs;
create policy "company update own jobs"
on public.jobs
for update
using (
  public.is_admin() or (public.is_company() and owner_id = auth.uid())
)
with check (
  public.is_admin() or (public.is_company() and owner_id = auth.uid())
);

drop policy if exists "company delete own jobs" on public.jobs;
create policy "company delete own jobs"
on public.jobs
for delete
using (
  public.is_admin() or (public.is_company() and owner_id = auth.uid())
);

-- ------------------------------
-- Trigger: create profile on signup
-- ------------------------------
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
as $$
begin
  insert into public.profiles (id, email, role)
  values (new.id, new.email, 'user')
  on conflict (id) do update set email = excluded.email;
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();

-- Optional: keep profiles.email in sync if user changes email
create or replace function public.handle_user_email_change()
returns trigger
language plpgsql
security definer
as $$
begin
  update public.profiles set email = new.email where id = new.id;
  return new;
end;
$$;

drop trigger if exists on_auth_user_updated on auth.users;
create trigger on_auth_user_updated
after update of email on auth.users
for each row execute procedure public.handle_user_email_change();
